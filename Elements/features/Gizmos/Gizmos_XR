from Elements.pyGLV.GL.Scene import Scene
from Elements.pyECSS.Entity import Entity
from Elements.pyECSS.Component import BasicTransform
import Elements.pyECSS.math_utilities as util
from Elements.pyECSS.Component import BasicTransform, RenderMesh
from Elements.pyGLV.GL.VertexArray import VertexArray
import sdl2 as sdl
from Elements.pyGLV.GL.Shader import Shader, ShaderGLDecorator
from ctypes import c_int, byref
from Elements.features.XR.ElementsXR import RayDirection
from OpenGL.GL import GL_LINES
from math import sqrt, pow
import numpy as np
import Elements.utils.normals as norm
import imgui
import enum
from Elements.features.XR.ElementsXR import ElementsXR_program
from Gizmos import Gizmos, Mode


class Gizmos_XR(Gizmos):

    def __init__(self, rootEntity: Entity):
        super().__init__(rootEntity)

        self.program: ElementsXR_program
        self.program = None
        
        self.origin_left = util.vec(0.0,0.0,0.0,0.0)
        self.origin_right = util.vec(0.0,0.0,0.0,0.0)
        self.direction_left = util.vec(0.0,0.0,0.0,0.0)
        self.direction_right = util.vec(0.0,0.0,0.0,0.0)

        self.left_grab_lock = False
        self.left_grab_counter = 0;

    def update_projection(self, Proj):
        """
        Update window's projection and calculate its inverse, if needed
        Arguments:
            self: self
            Proj: Projection matrix
        Returns:
            None
        """
        raise NotImplementedError("Projection is only used for Gizmos on a window")
    
    def update_view(self, View):
        """
        Update window's View and calculate its inverse, if needed
        Arguments:
            self: self
            View: View matrix
            Returns:
                None
        """
        raise NotImplementedError("View is only used for Gizmos on a window")

    def __update_positions(self):
        """
        Uniform variables used for Model/View/Projection are updated inside Render View at graphics plugin
        Arguments:
            self: self
        Returns:
            None
        """
        return
    
    def update_ray_start(self):
        """
        Update mouse position and mouse state. Additionally Raycast or try to pick an Entity
        Arguments:
            self: self
        Returns:
            None
        """
        raise NotImplementedError("Use a different prototype for this method")
    
    def get_Event(self):
        """
        When the user presses the left controller grab buttons do one of the following:
            First time: Change target and use Translate mode
            Second time: use Scale mode
            Third time: use Rotation mode
            Fourth time: go back to first
        Arguments:
            self: self
        Returns:
            None
        """
        #if left trigger was pressed, then change target and.or transformation
        assert self.program is not None

        grab_values = self.program.grab_values
        if grab_values[0]:
            if not self.left_grab_lock:
                self.left_grab_lock = True
                self.left_grab_counter +=1

                if self.left_grab_counter==4:
                    self.left_grab_counter = 1

                if self.left_grab_counter==1:
                    self.mode = Mode.TRANSLATE
                    self.change_target()
                elif self.left_grab_counter==2:
                    self.mode==Mode.SCALE
                elif self.left_grab_counter==3:
                    self.mode = Mode.ROTATE
        else:
            self.left_grab_lock = False

    def update_ray_start(self,RaysDirections: list[RayDirection]):
        """
        Update the ray's starting point based in the controllers' model and mesh
        Arguments:
            self: self
        Returns:
            None
        """
        left_origin = RaysDirections[0].origin
        right_origin = RaysDirections[1].origin
        left_direction = RaysDirections[0].direction
        right_direction = RaysDirections[1].direction


        self.origin_left = util.vec(left_origin[0],left_origin[1],left_origin[2],0.0)
        self.origin_right = util.vec(right_origin[0],right_origin[1],right_origin[2],0.0)
        self.direction_left = util.vec(left_direction[0],left_direction[1],left_direction[2],0.0)
        self.direction_right = util.vec(right_direction[0],right_direction[1],right_direction[2],0.0)

    def calculate_ray(self):
        """
        Return last origin and direction taken from the right controller
        Arguments:
            self: self
        Returns:
            a ray's starting position and direction
        """
        return self.origin_right, self.direction_right